---
title: "Full NGINX Tutorial: Demo Project with Node.js & Docker"
datePublished: Fri Nov 29 2024 13:30:51 GMT+0000 (Coordinated Universal Time)
cuid: cm42s7ihx000309js4u4lfv51
slug: full-nginx-tutorial-demo-project-with-nodejs-docker
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1732887182467/c8ed332b-00c2-4b7f-9205-bacb482ee2d8.webp
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1732887219515/8e1b5fe6-0b5b-4baa-b9c3-c0e879860a0a.webp
tags: nginx, nginx-project, nginx-configuration-guide, nginx-installation-tutorial

---

## **Overview**

1. **What is NGINX?**
    
    * Learn the fundamentals of NGINX and its functionalities.
        
2. **NGINX Use Cases**
    
    * Discover how NGINX acts as a web server, load balancer, caching server, and more.
        
3. **How to Configure NGINX?**
    
    * Explore configuration examples for various scenarios.
        

---

## **What is NGINX?**

NGINX is a fast, lightweight, and high-performance open-source web server. Initially designed for HTTP web serving, it has evolved to include functionalities such as:

* **Reverse proxying**
    
* **Load balancing**
    
* **Caching**
    
* **SSL/TLS termination**
    

---

## **NGINX Use Cases**

### 1\. **NGINX as a Web Server**

NGINX serves static files like HTML, CSS, and JavaScript efficiently, handling concurrent requests to ensure maximum performance under heavy loads.

### 2\. **NGINX as a Load Balancer**

NGINX distributes incoming web traffic across multiple servers to prevent bottlenecks. Common algorithms include:

* **Round-robin**
    
* **Least connections**
    

### 3\. **NGINX as Caching**

NGINX caches responses from backend servers, storing them temporarily for faster delivery of repeated requests.

### 4\. **NGINX for Security**

As a single entry point, NGINX minimizes the exposure of backend servers. It also handles SSL/TLS termination, ensuring secure communication.

### 5\. **NGINX for Compression**

NGINX reduces bandwidth consumption by compressing responses and sending data in chunks, optimizing scenarios like video streaming.

---

## **How to Configure NGINX?**

NGINX configuration is managed through its configuration file (`nginx.conf`), typically located in `/etc/nginx/nginx.conf`. Key sections include:

### Common Configuration Blocks

* **http**: Manages web traffic settings.
    
* **server**: Defines virtual hosts and ports.
    
* **location**: Specifies file paths or proxy rules.
    

### Common Directives

* `listen`: Specifies the IP and port for incoming requests.
    
* `server_name`: Defines the domain or IP address.
    
* `root`: Sets the directory for static files.
    
* `index`: Customizes default index files.
    

---

### **Examples**

#### 1\. **NGINX as a Web Server**

```plaintext
server {
    listen 80;
    server_name example.com;
    location / {
        root /var/www/example.com;
        index index.html index.htm;
    }
}
```

**Explanation:**

* `listen 80`: Listens for HTTP traffic on port 80.
    
* `root`: Points to the websiteâ€™s files.
    
* `index`: Specifies default files.
    

---

#### 2\. **NGINX as a Reverse Proxy**

```plaintext
server {
    listen 80;
    server_name api.example.com;

    location / {
        proxy_pass http://backend_server_address;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

**Explanation:**

* `proxy_pass`: Forwards client requests to a backend server.
    
* `proxy_set_header`: Adds headers for tracking requests.
    

---

#### 3\. **Redirecting HTTP to HTTPS**

```plaintext
server {
    listen 80;
    server_name example.com www.example.com;

    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name example.com www.example.com;

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

    location / {
        root /var/www/example.com;
        index index.html index.htm;
    }
}
```

**Explanation:**

* Redirects HTTP traffic to HTTPS.
    
* Configures SSL certificates for secure communication.
    

---

#### 4\. **NGINX as a Load Balancer**

```plaintext
http {
    upstream myapp {
        least_conn;
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }

    server {
        listen 80;
        location / {
            proxy_pass http://myapp;
        }
    }
}
```

**Explanation:**

* `upstream`: Defines backend servers.
    
* `least_conn`: Routes traffic to the least busy server.
    

---

#### 5\. **NGINX as Caching**

```plaintext
http {
    proxy_cache_path /data/nginx/cache keys_zone=mycache:10m;

    server {
        listen 80;

        location / {
            proxy_cache mycache;
            proxy_pass http://backend_server_address;
        }
    }
}
```

**Explanation:**

* `proxy_cache`: Enables response caching.
    
* `keys_zone`: Allocates memory for cached responses.
    

---

## **NGINX as Kubernetes Ingress Controller**

In Kubernetes, the NGINX Ingress Controller handles external access to services by managing routing rules defined in ingress resources. Unlike cloud load balancers, it operates internally within the cluster, providing advanced traffic management without exposing the cluster publicly.

**Build a Simple Node.js Application: Dockerize, Configure NGINX, Load Balance, and Secure with HTTPS**

## **Prerequisites**

Ensure the following are installed on your system:

1. **Node.js** and **npm**
    
2. **Docker Desktop**
    

---

## **Step 1: Run the Web Application Locally**

### **1\. Install Dependencies**

Clone the repository and navigate to the project directory.  
Git clone [https://github.com/imkiran13/NGINX-Tutorial-Demo-Project-with-Node.js-Docker.git](https://github.com/imkiran13/NGINX-Tutorial-Demo-Project-with-Node.js-Docker.git)

Run the following command to install required packages:

```plaintext
npm install
```

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdGBCXdevPjjzryKzgt9ZqcODU7eKQm4EIoBPkNqAAm8eJrrW16f_z9TNMZvPei2zHr55KG0af8T7ArgYaTTx-78syaQF_9EjMu6m-3Y_zU99VTG4MD4k55s33tcLUNGHMZWbAs?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

### **2\. Start the Application**

Run the application using:

```plaintext
node server.js
```

This will start the backend server, serving static files and assets locally.

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdsGo9OItRnL7ArVqaWPCX9-B9ave7IKLVS2ClSh9GRUdAQH0JiLI56BgFh8pieWZ0UMRndiXvA8fU3IQhgK3BSeh1LEu_ZkccZFElrpGGPbiTjTW0nCRMhpmBfLrTcACfywN8T1g?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdZoZe1VjU6uAeJgrofR8xJmrvhYFBGdiip6Nim81fMnAjxvN84fxX3kMsoi0xN65mRzIpXiRPmZsuTcbyAkuRNkz7fLLqG7MswL-oB0pCziUSTKBNZQ24Jbx0fCh59PCyVMNZwyQ?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

## **Step 2: Dockerize the Node.js Application**

### **1\. Dockerfile**

Create a `Dockerfile` to containerize the Node.js application:

```plaintext
FROM node:14

WORKDIR /app

COPY server.js .
COPY index.html .
COPY images ./images
COPY package.json .

RUN npm install

EXPOSE 3000

CMD ["node", "server.js"]
```

### **2\. Build Docker Image**

Run the following command to build the Docker image:

```plaintext
docker build -t myapp:1.1 .
```

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcqHs5GSJUpYU_5UCbcbvYZWfwlscC3REimRmURAksqOgsk9F4OFWpQmqv8HdMGUxRTxSyi7MZXi093PMuajicHinaR0dfWvkY4hyD4sd3FhYLT3Y2MRklfwC4BeP-QSZBsZnQwEA?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfIVU7PPo_bcmr-YJefWtqonklDwQrZ5-d8KZG2KuDw3ax9_N_foPWjBpwVwcxNyGEVIIYlQQNrHyXmVfWcv_oVoW-DO1rupmI-GpWHp9FlHERJyhngUM98ODaiLGRC-nYXEuiCAw?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

### **3\. Run the Docker Container**

Start the container and expose it on port 3000:

```plaintext
docker run -it -p 3000:3000 myapp:1.1
```

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcqyfNNxLUj4haXIexr6ZfxBLenwXZ8AcN0Ajl21edkwwkmam5m6tx4e8DuLfXs9WAPblI41TbHvDzTg_dQypbKFMhDGaqBFGVEpNPsds04oyFLOPQHRek39R8cOVDjaLB_zkIAwQ?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdQfSGiQ8dsMfjA4kPTX3YVcnpAE4D53mT8meGp-PwvInd4FoGUk9HAozX6tfNA2IXwEt5360aZZNzvZZ614w8zOkF7gIEURrGNAh1bWd2rhiDetsdyULtW4eIe-Z_c6MRueiTqfA?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

## **Step 3: Run Multiple Services with Docker Compose**

To run multiple instances of the app for load balancing, create a `docker-compose.yml` file:

```plaintext
version: '3'
services:
  app1:
    build: .
    environment:
      - APP_NAME=App1
    ports:
      - "3001:3000"

  app2:
    build: .
    environment:
      - APP_NAME=App2
    ports:
      - "3002:3000"

  app3:
    build: .
    environment:
      - APP_NAME=App3
    ports:
      - "3003:3000"
```

### **1\. Start Services**

Run all services with:

```plaintext
docker-compose up --build -d
```

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXe_TMRe5zIak3NXPcdFnAdrB2LDPg24MTq4-7hTYLhQ2CVck8Gh-L_UBsNGeMjaXxftbZSD6Qc5O_WWS2YzF4Y19eIfsnx2HRayqEDvafryXn9dzIfZqkchFTOEZCKoX2q3wk_0rQ?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeBuZUlP5-yCC_MghaJQyWOZYeSj7RXYutrUGikw2gVY5-jrj7ulfp3eNdpIYGQuZc1Ogy_W5B5TwVaSEQdMpBjbaA3zFruHal6hxfnll9P3BZQ-7TgLxMWNtI_XLxGNP8TxTYU?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdJc0QyoCLfIzB5Hu7N2tYovkU7hzrhbJph_P_9dbrnjcND1b5oYcbMso6QxFeTinNwwkuVe7JAq5of09Zi7kuiS_fPOAwTQ5EiUbTiRLApoNfQoIWPid1hHYcCGrbKWXTJ8eAbBQ?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXd2Ip5Uq62vP6idXln2NTeH8d0FFzLegVGoaQmqrODq13m2TWTzoSYMDghLXJ7jE5IYbClGw_VCSJGzOA-byLkq4l2iPyC2i6LhTEMUfxhbF6NL4vyCiNd5iErUyIcyh9W0adfb9w?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

### **2\. Stop Services**

To stop and remove containers, use:

```plaintext
docker-compose down
```

Configure NGINX so that we do not want to access each server separately. We want 1 entry point which forwards the request to one of the backend servers.

## **Step 1: Launch an AWS EC2 Instance**

### **1\. Access the AWS Management Console**

* Navigate to the **EC2 Dashboard**.
    
* Launch a new EC2 instance.
    

### **2\. Choose Configuration**

* **OS:** Ubuntu (latest version recommended).
    
* **Instance Type:** t2.micro (sufficient for small-scale testing).
    
* **Security Groups:**
    
    * Allow inbound traffic on:
        
        * **HTTP (80)**
            
        * **HTTPS (443)**
            
        * **SSH (22)**
            
        * **Custom TCP(8080,3000,3001,3002,3003)**
            
        * ![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeyp_d2GaDDIyAj9phaQEucXohH9qtnRiaisiGFkQGcmcTbPYzWU4Qy1gc05Okrd7KXshYRcyNv-erCXlEsqyH1BRQdtwjCuYrIwfWEg-xHzX_MSDpdg9vJPNQS9tCQ3WRYJgfpPA?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")
            

### **3\. Connect to Your Instance**

Use SSH to connect:

```plaintext
ssh -i your-key.pem ubuntu@your-instance-public-ip
```

---

## **Step 2: Update System and Install Dependencies**

### **1\. Update Packages**

```plaintext
sudo apt update && sudo apt upgrade -y
```

### **2\. Install Docker and Docker Compose**

```plaintext
sudo apt install docker.io -y
sudo usermod -aG docker $USER
sudo systemctl enable docker 
sudo systemctl start docker
sudo curl -L "https://github.com/docker/compose/releases/download/$(curl -s https://api.github.com/repos/docker/compose/releases/latest | jq -r .tag_name)/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
```

### **3\. Install NGINX**

```plaintext
sudo apt install nginx -y
sudo systemctl enable nginx
sudo systemctl start nginx
```

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnyska82h7PqCkA9wu4tTgzcN0MNLDcuYHajkMeCHoEg3eJF3fYfh578Psuer_3AIe4o3Hv0rj_eouc3vqLIJnkRWqmDiSSvvZTlxyTAwuqSHjoeSjVocmp54N6jrNcjsUS0eDiw?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

### **4\. Install Node.js and npm**

```plaintext
sudo apt install nodejs npm -y
```

---

## **Step 3: Clone the Node.js Repository**

```plaintext
git clone https://github.com/imkiran13/NGINX-Tutorial-Demo-Project-with-Node.js-Docker.git
```

```plaintext
cd NGINX-Tutorial-Demo-Project-with-Node.js-Docker
sudo npm install
```

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfAr7fwbafXfysQMh0ulr8mooq48JNh-ZCXRTOT7w7JtwJVYnU4523S-ilEumAQrim2bsYt72FFAre1G1SsxD83W8jzW_PaiHw2U4rGF_SNsCtys2PlnLDyVx0CueEdPqVyV54GpA?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

Test the application locally:

```plaintext
sudo node server.js
```

Access the app at [`http://ec2-public-ip:3000`](http://localhost:3000).

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXf7zVEVt3E5jTjF6XFLKRRvI_lp-dMpRD9G0RVWNQ4UGSsjdfXar03rMt9YlJxzR42mWWmxeidlb44TwNsrbkmjSEb-UTA9nTPYC9yw_jWxfoys7ofcdWO5Jj9Fi--544KPfJhMuA?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

---

## **Step 4: Configure NGINX for Load Balancing**

### **1\. Create a Configuration File**

Create a new NGINX configuration file:

```plaintext
sudo vim /etc/nginx/sites-available/nodejs
```

Paste the following configuration:

```plaintext
upstream nodejs_cluster {
    least_conn;
    server 13.126.218.233:3001; #public-ip-ec2 and application port
    server 13.126.218.233:3002;
    server 13.126.218.233:3003;
}

server {
    listen 8080;
    server_name 13.126.218.233;

    location / {
        proxy_pass http://nodejs_cluster;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

### **2\. Enable the Configuration**

Create a symbolic link to `sites-enabled`:

```plaintext
sudo ln -s /etc/nginx/sites-available/nodejs /etc/nginx/sites-enabled/nodejs
```

Remove the default configuration to prevent conflicts:

```plaintext
sudo rm /etc/nginx/sites-enabled/default
```

### **3\. Verify and Reload NGINX**

```plaintext
sudo nginx -t
sudo systemctl reload nginx
```

**Let us check to which server is the request getting forwarded to.**

Open the ec2-public-ip with port 8080, and check the developer tab. Clear the cache and check the network tab to see the server as Nginx. This means that the request is going through Nginx.

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdtWuVrGqTbO48XlgT2egrf8DGUMuZegy4U4eXzN3E37JHO6_zLpgTtmRzQckKy6nRqlaBPKRLPJoeMQFLL0ab99O5l_IC5kGdR701j7-_uCusYjoYCbQVG1-F5S-1yvz9PRFHtiw?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

If you open the public-ip with port 3001, in the network tab you can see there is no server configuration displayed. This means that the request is going directly to the first server.

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdnnTbgDk70o68RG66soty2_dpCWs38qQLiGWfHreK1ov7g4TOgSpBlRgG3jHN9-4UOP8LnERHxTXpMh_hJ72Up4jLYPdonHjEchAMh5lyzGVBJIjopV84iaztoAC2PG4HwrgDF?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

## **Step 5: Add HTTPS with Self-Signed Certificates**

**Configure HTTPS for a Secure Connection**

In todayâ€™s world security is a paramount. Configuring HTTPS on your web server is a crucial part to protect sensitive data. We will implement a robust certificate management system, with that we can ensure all the communications between the client and the server are encrypted.

**There are usually two ways to implement this certificate process**

**1\. Use Letâ€™s Encrypt** (A Certificate Authority) using Certbot which issues free certificates. However, you need to have a Domain for this type. This is used for production type cases.

**2\. Use Self-Signed Certificate**.

This is not a perfect solution though, it will show a warning that they have a certificate but it is not issued from a Certificate Authority. This is often used for testing and development.  
In this article, we will be using the 2nd option as we are using for testing purpose only.

### **1\. Generate SSL Certificates**

Create a directory to store SSL files:

```plaintext
mkdir ~/nginx-certs
cd ~/nginx-certs
```

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeVXwf1XpQmbVbMzid-bK3g1bH0CIC9s9v3gh3wjI4PcLRlvxUHU3udPw8qj5rtZZ2mmMOiflssy2P1oKsNFPrjSPUGzTZtWrgG4JNG1qL4u2ovXn4jfJawoQ2qyIU4XeC0bT9HIQ?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

Generate a self-signed certificate:

```plaintext
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout nginx-selfsigned.key -out nginx-selfsigned.crt
```

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXflzFtWJOiEuHypFopfcf6xegQvZbBVsWlHaWxs2e2EyorQ8lhP0q_-hFdqHY7pLrQ6lc_mdIUXgWQtYfAN6bPjDVDdwRNeR03YNA-f4r38zhJ_C6vad_y6UV26prLirEktSbcCUQ?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

**Verify Certificate Files**  
Check that both the certificate and private key have been created successfully:

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfUKI5SgjJIJRkPODvlo28GJCWj4hWq3_mnTRWVx0sRRm3D8GNueT2F4kDcMKxsQ22_nYVddXjiMBS6do29rpuU2i88IwkXK9x2ngERWJzIWjjQrlBykf-g0zyjc9femPEdQLSy?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

* nginx-selfsigned.crt (Certificate)
    
* nginx-selfsigned.key (Private key)
    

### **2\. Update NGINX Configuration**

Edit `/etc/nginx/nginx.conf` to include HTTPS:

```plaintext
sudo vim /etc/nginx/nginx.conf
```

Paste the configuration:

```plaintext
nginxCopy codeupstream nodejs_cluster {
    least_conn;
    server 13.126.218.233:3001;
    server 13.126.218.233:3002;
    server 13.126.218.233:3003;
}

server {
    listen 443 ssl;
    server_name 13.126.218.233;

    ssl_certificate /home/ubuntu/nginx-certs/nginx-selfsigned.crt;
    ssl_certificate_key /home/ubuntu/nginx-certs/nginx-selfsigned.key;

    location / {
        proxy_pass http://nodejs_cluster;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

server {
    listen 8080;
    server_name 13.126.218.233;

    location / {
        return 301 https://$host$request_uri;
    }
}
```

### **3\. Test and Restart NGINX**

```plaintext
sudo nginx -t
sudo systemctl restart nginx
```

---

## **Step 6: Verify the Setup**

1. **Access Application via HTTPS**:  
    Open [`https://13.126.218.233`](https://13.126.218.233) in your browser.  
    (Accept the warning for the self-signed certificate.)
    
2. **Test HTTP to HTTPS Redirection**:  
    Navigate to [`http://13.126.218.233:8080`](http://13.126.218.233:8080), which should redirect to HTTPS.
    
3. **Verify Load Balancing**:  
    Use the browser's developer tools or refresh multiple times to observe requests being distributed among servers.
    

---

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdLahitvddPiuTyzBDsScEkpCd_Nh341G-uL3IA4JmrJtiI8uA135EY2xC61OV2LlHqFYa8tHNsXuz4QXihD7fF5QsIvFz4vyB4Q-TBN0oRe87DXWbIjbNgehS5PGg3xUcc5fUyew?key=u3kgL3rYXrvs-5CLAu_EUfQs align="left")

As you can see the site gets loaded with https, but since it is a self signed certificate it shows it is not a valid certificate.You can also try to access the site on [public-ip:8080](http://localhost:8080) which will redirect to the secured https site.

By the way, the default port for http is port 80. You can make the change in the config file and see the changes.

This is how one can use Nginx as a reverse proxy server no matter which techstack youâ€™re using

## **Clean Up**

1. **Stop NGINX**:
    
    ```plaintext
    sudo systemctl stop nginx
    ```
    
2. **Stop Docker Containers**:
    
    ```plaintext
    docker-compose down
    ```
    

---

## **Conclusion**

This guide demonstrated how to:

* Set up NGINX as a reverse proxy and load balancer.
    
* Secure connections using self-signed SSL certificates.
    
* Redirect HTTP traffic to HTTPS.
    

With NGINXâ€™s extensive features like load balancing and SSL/TLS support, it is an ideal solution for modern web infrastructure. If you have any questions, feel free to ask! ðŸš€